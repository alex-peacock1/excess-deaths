---
jupyter:
  jupytext:
    notebook_metadata_filter: all,-language_info
    split_at_heading: true
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.15.2
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
  widgets:
    application/vnd.jupyter.widget-state+json:
      state: {}
      version_major: 2
      version_minor: 0
---

# Is there a link between certain Covid-19 vaccines and 2023 excess all-cause mortality?

 To remember:
- Need EU scope in the title?
- ONLY homemade functions in .py files
- check we are using excess death and excess mortality right throughout
- rename variables clearly
- comments on lines of code

```{python}
#Importing necessary libraries 
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt 
import scipy.stats as sps

# Safe setting for Pandas.  Needs Pandas version >= 1.5.
pd.set_option('mode.copy_on_write', True)

#Importing our fetch data file 
import fetch_data
```

### Introduction 

This project aims to investigate excess all-cause mortality across EU countries post-covid-19 pandemic, and the role of Covid-19 vaccines as a potential cause. 

The term excess death refers to the (absolute?) difference between the number of observed and expected deaths (CITE) in a given period. To better enable comparisons across countries with large diferrence in population, this project investigates excess *mortality*, which refers to the percentage difference between the observed and expected number of deaths.

In particular, we will be looking at all-cause excess mortality,which refers to the percentage difference in the number of people who died from any cause in a given period, compared to the expected number of deaths from any cause in that given period.

We will employ multiple linear regression in order to investigate the relationship between Covid-19 vaccination and excess mortality across 31 countries (27 EU countries and 4 countries from the European Free Trade Association).

- Explain reasoning for EU scope - the wealth of data across countries makes it possible to compare vaccination types etc

### Literature review

- UK parliment speech to introduce our focus on Covid-19 vaccines as a potential cause of excess death - MP mentioned that it was the single thing which affected the whole population etc
- Trust the evidence critiqued UK report 'Trends in Excess Deaths and Covid-19 Vaccines' for referring to Covid-vaccine as singular despite varying types - we will therefore investigate each vaccine type
- ^^^ Mayb also link to evidence for scepticism/withdrawal of certain vaccine types to emphasise the differences between vaccines
- What else has relevant existing literature done/found and what are the gaps - therefore what are we trying to find/do


### Excess mortality data 

Eurostat's excess mortliaty indicator is part of European Statistical Recovery Dashboard and takes the number of people who died from any cause in a given period and compares it with a historical baseline from previous years. In the case of our data, this baseline consists of the average number of deaths that occurred each month during the period 2016-2019.

Therefore, when referring to excess mortality throughout this project, we will be referring to the percentage difference in additional deaths from any cause when compared with the average monthly deaths in 2016-2019. The higher the value, the higher the number of additional deaths, with negative numbers indicating fewer deaths compared to the basline period.

The excess mortality indicator is based on a data collection in which National Statistical Institutes from the European Union (EU) and the European Free Trade Association (EFTA) have transmitted weekly deaths data to Eurostat on a voluntary basis since April 2020. This weekly deaths dataset is then used to compute the monthly excess mortality indicator by mapping the deaths of each week to a full month. 

The data covered in this analysis include all deaths that have occurred since January 2020 and up until ....

-  mention possible limitations of this measure & of the 2016-2019 baseline 
-  acknowledge the fact that we haven't been able to determine the variance of excess mortality prior to/during 2016-2019

#### Cleaning excess mortality data

```{python}
#Reading in initial excess mortality data
excess_deaths = pd.read_excel('data/excess_death.xlsx', sheet_name = 'Sheet 1', skiprows=7, skipfooter=6)
```

The data has downloaded in an awkward format. The country column is labelled as 'TIME'. Each month excess mortality data point also comes with an adjacent column labelling whether it is real data, provisional or estimated. Countries are also labelled with their full names.
In order to work with the data...

```{python}
# Remove columns labelling rates that are estimated or provisional data ** RETURN TO THIS
excess_deaths_values = excess_deaths.loc[:, ~excess_deaths.columns.str.startswith('Unnamed')][1:]

# Make index country names
excess_deaths_values = excess_deaths_values.set_index('TIME').rename_axis('Country')

# Add a mean excess death by EU country for 2023 
excess_deaths_values = excess_deaths_values.apply(pd.to_numeric, errors='coerce')
excess_deaths_values['Mean 2023'] = excess_deaths_values.iloc[:, -9:].mean(axis = 1)
excess_deaths_values.sort_values('Mean 2023')


country_code_dict = {
    'Belgium': 'BE', 
    'Bulgaria': 'BG', 
    'Czechia': 'CZ', 
    'Denmark': 'DK', 
    'Germany': 'DE', 
    'Estonia': 'EE',
    'Ireland': 'IE', 
    'Greece': 'GR', 
    'Spain': 'ES', 
    'France': 'FR', 
    'Croatia': 'HR', 
    'Italy': 'IT',
    'Cyprus': 'CY', 
    'Latvia': 'LV', 
    'Lithuania': 'LT', 
    'Luxembourg': 'LU', 
    'Hungary': 'HU', 
    'Malta': 'MT',
    'Netherlands': 'NL', 
    'Austria': 'AT', 
    'Poland': 'PL', 
    'Portugal': 'PT', 
    'Romania': 'RO',
    'Slovenia': 'SI', 
    'Slovakia': 'Sk', 
    'Finland': 'FI', 
    'Sweden': 'SE', 
    'Iceland': 'IS',
    'Liechtenstein': 'LI',
    'Norway': 'NO', 
    'Switzerland': 'CH', 
    }
#Adding a new column called 'ReportingCountry' with associated country codes
excess_deaths_values['ReportingCountry'] = excess_deaths_values.index.map(country_code_dict)
```

### COVID-19 Vaccination data


Our data on COVID-19 vaccination comes from the European Centre for Disease Prevention and Control's Vaccine Tracker.

The data is collected through The European Surveillance System (TESSy), and are submitted by European Union/European Economic Area countries to the ECDC once every four weeks. EU/EEA Member States report aggregated vaccination data by age and specific target groups, with doses reported by vaccine product.

#### Cleaning vaccination data

```{python}
#Reading in initial vaccination data
base_vaccine_data = pd.read_excel('data/vaccine_types.xlsx')
base_vaccine_data.head()
```

We decided to initally only focus on first doses of Covid-19 vaccinations so removed the other columns for now. 

```{python}
#Dropping unwanted columns
first_doses_only = base_vaccine_data.drop(['Denominator', 'NumberDosesReceived', 'NumberDosesExported', 'FirstDoseRefused', 'SecondDose', 'DoseAdditional1', 'DoseAdditional2', 'DoseAdditional3', 'DoseAdditional4', 'DoseAdditional5', 'UnknownDose'], axis = 1)
first_doses_only
```

After spotting that the data included a row for each region as well as one for the full country, we then reduced the dataframe to those show the total vaccine count per country.

```{python}
#Remove regions to only get full country
total_first_dosage_count = first_doses_only[first_doses_only['ReportingCountry'] == first_doses_only['Region']]
total_first_dosage_count
```

not sure the reason for the dropping dupes below?

```{python}
#Drop duplicate rows
base_vaccine_data = total_first_dosage_count.drop_duplicates(subset = ['YearWeekISO', 'ReportingCountry', 'FirstDose'])
```

### Analysis

##### Inital regression of mean excess mortality against vaccination percentage for EU countries

```{python}
#Adding a year column
base_vaccine_data['Year'] = base_vaccine_data['YearWeekISO'].str[:4].str.strip()

#Working out the number of people in each country vaxed by the end of 2022, filtering so only data for 'ALL' target group is considered as age specific counts were unreliable, summing the first dose after grouping by target group and reporting country
total_vaxed_up_to_23 = base_vaccine_data[base_vaccine_data['Year'] != '2023'][base_vaccine_data['TargetGroup'] == 'ALL'].groupby('ReportingCountry')['FirstDose'].sum()

#taking the population for each country in as of the first week of 2023
population_wk1_23 = base_vaccine_data[base_vaccine_data['YearWeekISO'] == '2023-W01'].groupby('ReportingCountry')['Population'].first()

#Converting the number of people vaccinated into a proportion of the population
percent_vaxed_wk1_23= total_vaxed_up_to_23/population_wk1_23
percent_vaxed_wk1_23

just_code_and_mean = excess_deaths_values[['ReportingCountry', 'Mean 2023']]

#Merging the data frames on the ReportingCountry column, resulting in a data frame with ReportingCountry code, mean excess deaths in 2023 and 
# % of population vaxed as of the end of 2022
merged = pd.merge(just_code_and_mean, pd.DataFrame(percent_vaxed_wk1_23), on = 'ReportingCountry')

#Regressing  the percent vaxed against the mean excess deaths
regression = sps.linregress(merged[0], merged['Mean 2023'])
```

```{python}
import matplotlib.pyplot as plt

plt.scatter(merged[0],merged['Mean 2023'])

for i in range(len(merged)):
    plt.text(merged[0][i] + 0.01, merged['Mean 2023'][i], merged['ReportingCountry'][i], fontsize=8)
 
plt.xlabel('Percent Vaccinated as of 2023')
plt.ylabel('Mean Excess Deaths 2023')
plt.title('Vaccination uptake versus mean excess deaths')
plt.plot(percent_vaxed_wk1_23, regression[1] + regression[0]*percent_vaxed_wk1_23, 'r', label='fitted line')

plt.show()
```

```{python}
regression.rvalue
```


```{python}
regression.pvalue
```

This initial linear regression plot yeilded an correlation coefficient of 0.63, indicating a moderate postitive correlation between mean 2023 excess all-cause mortality and vaccination percentage. A positive correlation suggests that the higher a country's proportion of vaccinated individuals, the higher their levels of excess all-cause mortality (dk how best to say this).

A very small p-value of 0.0003 enables us to have high confidence that the observed correlation did not arise from our null-model of no correlation, and therefore we have reason to prefer to the alternative hypothesis, that higher vaccination percentage is associated with higher excess mortlaity. In other words, the result is unlikley to have happened by chance when there is no correlation, and therefore we can be relatively confident in the (validity?) of our results.

- Comment on any anomalies

##### Residual error plot



In order to check whether the relationship between a country's percentage of vaccinated individals and its excess mortality is best represented by a straight line, we then decided to plot the distribution of the residual errors from the above linear regression.


First we decided to create a plot demonstrating the residual errors for each data point.

```{python}
#Creating a function for the residual error plot
def plot_with_errors(x_values, y_values, c, s):
    
    predicted = c + s * x_values
    
    errors = y_values - predicted
    
    plt.plot(x_values, y_values, 'o', color='blue')
    plt.plot(x_values, predicted, 'o', color='red')
    
    for i in np.arange(len(x_values)):
        x = x_values[i]
        y_0 = predicted[i]
        y_1 = y_values[i]
        plt.plot([x, x], [y_0, y_1], ':', color='black', linewidth=1)
    return np.sqrt(np.mean(errors ** 2))
```

```{python}
#A plot to demonstrate the acutal values, predicted values and residual error
plot_with_errors(merged[0], merged['Mean 2023'], regression.intercept, regression.slope)
plt.xlabel('Percent Vaccinated as of 2023')
plt.ylabel('Mean Excess Deaths 2023')
plt.title('Depicting residual error')
```

And then plotted the distribution of the residual errors.

```{python}
#Plotting a histogram of the residual errors
predicted = regression.intercept + regression.slope * merged[0]
plt.hist(merged['Mean 2023'] - predicted)
plt.xlabel('Residual error')
plt.ylabel('Frequency')
plt.title('Plotting the distribution of the residual errors')
```

<!-- #region -->
As there doesn't appear to be a pattern in how the residuals are distributed from left to right, we can be relatively confident of a linear relationship between the percentage of vaccinated individuals in a country and mean 2023 excess mortality.

#### CHECK THIS WITH MATTHEW ^^^
<!-- #endregion -->

##### Assumptions/limitations

- Using vaccination percentage up to 2023 then mean deaths since start of 2023
- Mean death across 2023 could flatten the seasonality of excess death?
- Just focusing on first doses
- Not done by vaccination type....
- Myabe think about additional doses
- We know it is correlated but the question is whether vaccination rate impacted excess death - look into confounding variables 

##### Regression of mean excess mortality against vaccination percentage for EU countries by vaccination 


- Import py file with Daniel's function to generalise vaccine type plots 

```{python}
by_type_and_country = base_vaccine_data[(base_vaccine_data['Year'] != '2023') & (base_vaccine_data['TargetGroup'] == 'ALL')].groupby(['ReportingCountry','Vaccine'])['FirstDose'].sum()
by_type_and_country = by_type_and_country.reset_index()
```


```{python}
population_wk1_23 = base_vaccine_data[base_vaccine_data['YearWeekISO'] == '2023-W01'].groupby('ReportingCountry')['Population'].first()
```

```{python}
by_type_and_country = pd.merge(by_type_and_country, population_wk1_23, on = 'ReportingCountry')
```

```{python}
by_type_and_country['% vaxed'] = by_type_and_country['FirstDose'] / by_type_and_country['Population']
```

```{python}
just_means = excess_deaths_values[['Mean 2023', 'ReportingCountry']]
```

```{python}
AZ = pd.merge(by_type_and_country[by_type_and_country['Vaccine'] == 'AZ'][['Vaccine','ReportingCountry','% vaxed']], just_means, on = 'ReportingCountry')
COM = pd.merge(by_type_and_country[by_type_and_country['Vaccine'] == 'COM'][['Vaccine','ReportingCountry','% vaxed']], just_means, on = 'ReportingCountry')
COMBA_1 = pd.merge(by_type_and_country[by_type_and_country['Vaccine'] == 'COMBA.1'][['Vaccine','ReportingCountry','% vaxed']], just_means, on = 'ReportingCountry')
COMBA_4_5 = pd.merge(by_type_and_country[by_type_and_country['Vaccine'] == 'COMBA.4-5'][['Vaccine','ReportingCountry','% vaxed']], just_means, on = 'ReportingCountry')
JANSS = pd.merge(by_type_and_country[by_type_and_country['Vaccine'] == 'JANSS'][['Vaccine','ReportingCountry','% vaxed']], just_means, on = 'ReportingCountry')
MOD = pd.merge(by_type_and_country[by_type_and_country['Vaccine'] == 'MOD'][['Vaccine','ReportingCountry','% vaxed']], just_means, on = 'ReportingCountry')
MODBA_1 = pd.merge(by_type_and_country[by_type_and_country['Vaccine'] == 'MODBA.1'][['Vaccine','ReportingCountry','% vaxed']], just_means, on = 'ReportingCountry')
MODBA_4_5 = pd.merge(by_type_and_country[by_type_and_country['Vaccine'] == 'MODBBA.4-5'][['Vaccine','ReportingCountry','% vaxed']], just_means, on = 'ReportingCountry')
NVXD = pd.merge(by_type_and_country[by_type_and_country['Vaccine'] == 'NVXD'][['Vaccine','ReportingCountry','% vaxed']], just_means, on = 'ReportingCountry')
UNK = pd.merge(by_type_and_country[by_type_and_country['Vaccine'] == 'UNK'][['Vaccine','ReportingCountry','% vaxed']], just_means, on = 'ReportingCountry')
VLA = pd.merge(by_type_and_country[by_type_and_country['Vaccine'] == 'VLA'][['Vaccine','ReportingCountry','% vaxed']], just_means, on = 'ReportingCountry')
SPU = pd.merge(by_type_and_country[by_type_and_country['Vaccine'] == 'SPU'][['Vaccine','ReportingCountry','% vaxed']], just_means, on = 'ReportingCountry') 
COMBIV = pd.merge(by_type_and_country[by_type_and_country['Vaccine'] == 'COMBIV'][['Vaccine','ReportingCountry','% vaxed']], just_means, on = 'ReportingCountry')         
MODBIV = pd.merge(by_type_and_country[by_type_and_country['Vaccine'] == 'MODBIV'][['Vaccine','ReportingCountry','% vaxed']], just_means, on = 'ReportingCountry')     
BECNBG = pd.merge(by_type_and_country[by_type_and_country['Vaccine'] == 'BECNBG'][['Vaccine','ReportingCountry','% vaxed']], just_means, on = 'ReportingCountry')               
SGSK = pd.merge(by_type_and_country[by_type_and_country['Vaccine'] == 'SGSK'][['Vaccine','ReportingCountry','% vaxed']], just_means, on = 'ReportingCountry')         
BHACOV = pd.merge(by_type_and_country[by_type_and_country['Vaccine'] == 'BHACOV'][['Vaccine','ReportingCountry','% vaxed']], just_means, on = 'ReportingCountry')       
SIN = pd.merge(by_type_and_country[by_type_and_country['Vaccine'] == 'SIN'][['Vaccine','ReportingCountry','% vaxed']], just_means, on = 'ReportingCountry')
```

```{python}
plt.scatter(AZ['% vaxed'], AZ['Mean 2023'])
plt.title('AZ')
```

```{python}
plt.scatter(COM['% vaxed'], COM['Mean 2023'])
plt.title('COM')
```

```{python}
plt.scatter(MOD['% vaxed'], MOD['Mean 2023'])
plt.title('MOD')
```

```{python}
plt.scatter(JANSS['% vaxed'], JANSS['Mean 2023'])
plt.title('JANNS')
```

### Further interrogation of the results



### Conclusion

- Areas for future research 





